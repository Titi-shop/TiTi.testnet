import { NextResponse } from "next/server";
import fs from "fs";
import path from "path";
import { put } from "@vercel/blob";

// ==============================
// üì¶ ƒê∆Ø·ªúNG D·∫™N L∆ØU FILE JSON
// ==============================
const dataDir = path.join(process.cwd(), "data");
const dataFile = path.join(dataDir, "products.json");

// ==============================
// üîß H√ÄM H·ªñ TR·ª¢
// ==============================

// ‚úÖ ƒê·ªçc danh s√°ch s·∫£n ph·∫©m
function readProducts() {
  try {
    if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });
    if (!fs.existsSync(dataFile)) fs.writeFileSync(dataFile, "[]", "utf-8");
    const data = fs.readFileSync(dataFile, "utf-8");
    return JSON.parse(data);
  } catch (error) {
    console.error("‚ùå L·ªói ƒë·ªçc file:", error);
    return [];
  }
}

// ‚úÖ Ghi d·ªØ li·ªáu s·∫£n ph·∫©m v√†o file JSON
function saveProducts(products: any[]) {
  try {
    fs.writeFileSync(dataFile, JSON.stringify(products, null, 2), "utf-8");
  } catch (error) {
    console.error("‚ùå L·ªói ghi file:", error);
  }
}

// ==============================
// üîπ GET ‚Äî L·∫•y danh s√°ch s·∫£n ph·∫©m
// ==============================
export async function GET() {
  const products = readProducts();
  return NextResponse.json(products);
}

// ==============================
// üîπ POST ‚Äî Th√™m s·∫£n ph·∫©m m·ªõi (Upload ·∫£nh l√™n Blob)
// ==============================
export async function POST(req: Request) {
  try {
    const formData = await req.formData();
    const name = formData.get("name") as string;
    const price = formData.get("price") as string;
    const description = formData.get("description") as string;
    const images = formData.getAll("images") as File[];

    if (!name || !price) {
      return NextResponse.json(
        { success: false, message: "Thi·∫øu th√¥ng tin s·∫£n ph·∫©m" },
        { status: 400 }
      );
    }

    // ‚úÖ Upload t·ª´ng ·∫£nh l√™n Blob Storage
    const uploadedUrls: string[] = [];
    for (const img of images) {
      if (!img || !img.name) continue;
      const buffer = Buffer.from(await img.arrayBuffer());
      const blob = await put(`uploads/${Date.now()}-${img.name}`, buffer, {
        access: "public",
        contentType: img.type,
      });
      uploadedUrls.push(blob.url);
    }

    // ‚úÖ T·∫°o s·∫£n ph·∫©m m·ªõi
    const products = readProducts();
    const newProduct = {
      id: Date.now(),
      name,
      price,
      description,
      images: uploadedUrls,
      createdAt: new Date().toISOString(),
    };

    products.push(newProduct);
    saveProducts(products);

    return NextResponse.json({ success: true, product: newProduct });
  } catch (err) {
    console.error("‚ùå L·ªói POST:", err);
    return NextResponse.json(
      { success: false, error: "L·ªói th√™m s·∫£n ph·∫©m" },
      { status: 500 }
    );
  }
}

// ==============================
// üîπ PUT ‚Äî C·∫≠p nh·∫≠t s·∫£n ph·∫©m
// ==============================
export async function PUT(req: Request) {
  try {
    const contentType = req.headers.get("content-type") || "";
    let updatedData: any = {};

    if (contentType.includes("application/json")) {
      updatedData = await req.json();
    } else if (contentType.includes("multipart/form-data")) {
      const formData = await req.formData();
      updatedData.id = Number(formData.get("id"));
      updatedData.name = formData.get("name");
      updatedData.price = formData.get("price");
      updatedData.description = formData.get("description");

      const images = formData.getAll("images") as File[];
      if (images.length) {
        updatedData.images = [];
        for (const img of images) {
          if (!img || !img.name) continue;
          const buffer = Buffer.from(await img.arrayBuffer());
          const blob = await put(`uploads/${Date.now()}-${img.name}`, buffer, {
            access: "public",
            contentType: img.type,
          });
          updatedData.images.push(blob.url);
        }
      }
    }

    if (!updatedData.id)
      return NextResponse.json(
        { success: false, message: "Thi·∫øu ID s·∫£n ph·∫©m" },
        { status: 400 }
      );

    const products = readProducts();
    const index = products.findIndex((p: any) => p.id === updatedData.id);
    if (index === -1)
      return NextResponse.json(
        { success: false, message: "Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m" },
        { status: 404 }
      );

    // Gi·ªØ h√¨nh c≈© n·∫øu kh√¥ng c√≥ ·∫£nh m·ªõi
    products[index] = {
      ...products[index],
      ...updatedData,
      images: updatedData.images || products[index].images,
    };

    saveProducts(products);
    return NextResponse.json({ success: true, product: products[index] });
  } catch (err) {
    console.error("‚ùå L·ªói PUT:", err);
    return NextResponse.json(
      { success: false, error: "L·ªói c·∫≠p nh·∫≠t s·∫£n ph·∫©m" },
      { status: 500 }
    );
  }
}

// ==============================
// üîπ DELETE ‚Äî X√≥a s·∫£n ph·∫©m
// ==============================
export async function DELETE(req: Request) {
  try {
    const { searchParams } = new URL(req.url);
    const id = Number(searchParams.get("id"));
    if (!id)
      return NextResponse.json(
        { success: false, message: "Thi·∫øu ID s·∫£n ph·∫©m" },
        { status: 400 }
      );

    const products = readProducts();
    const newProducts = products.filter((p: any) => p.id !== id);
    saveProducts(newProducts);

    return NextResponse.json({ success: true });
  } catch (err) {
    console.error("‚ùå L·ªói DELETE:", err);
    return NextResponse.json(
      { success: false, error: "Kh√¥ng th·ªÉ x√≥a s·∫£n ph·∫©m" },
      { status: 500 }
    );
  }
}
