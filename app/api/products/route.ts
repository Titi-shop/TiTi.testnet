import { NextResponse } from "next/server";
import fs from "fs";
import path from "path";

// ==============================
// üì¶ ƒê∆Ø·ªúNG D·∫™N L∆ØU TR·ªÆ D·ªÆ LI·ªÜU
// ==============================
const dataDir = path.join(process.cwd(), "data");
const dataFile = path.join(dataDir, "products.json");
const uploadDir = path.join(process.cwd(), "public", "uploads");

// ==============================
// üîß H√ÄM H·ªñ TR·ª¢
// ==============================

// ‚úÖ ƒê·ªçc danh s√°ch s·∫£n ph·∫©m (v√† t·ª± t·∫°o file n·∫øu ch∆∞a c√≥)
function readProducts() {
  try {
    if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });
    if (!fs.existsSync(dataFile)) fs.writeFileSync(dataFile, "[]", "utf-8");

    const data = fs.readFileSync(dataFile, "utf-8");
    return JSON.parse(data);
  } catch (error) {
    console.error("‚ùå L·ªói ƒë·ªçc file:", error);
    return [];
  }
}

// ‚úÖ Ghi d·ªØ li·ªáu v√†o file JSON
function saveProducts(products: any[]) {
  try {
    fs.writeFileSync(dataFile, JSON.stringify(products, null, 2), "utf-8");
  } catch (error) {
    console.error("‚ùå L·ªói ghi file:", error);
  }
}

// ==============================
// üîπ GET ‚Äî L·∫•y danh s√°ch s·∫£n ph·∫©m
// ==============================
export async function GET() {
  const products = readProducts();
  return NextResponse.json(products);
}

// ==============================
// üîπ POST ‚Äî Th√™m s·∫£n ph·∫©m m·ªõi
// ==============================
export async function POST(req: Request) {
  try {
    const formData = await req.formData();
    const name = formData.get("name") as string;
    const price = formData.get("price") as string;
    const description = formData.get("description") as string;
    const images = formData.getAll("images") as File[];

    if (!name || !price)
      return NextResponse.json(
        { success: false, message: "Thi·∫øu th√¥ng tin s·∫£n ph·∫©m" },
        { status: 400 }
      );

    // ‚úÖ T·∫°o th∆∞ m·ª•c upload n·∫øu ch∆∞a c√≥
    if (!fs.existsSync(uploadDir)) fs.mkdirSync(uploadDir, { recursive: true });

    const imagePaths: string[] = [];
    for (const img of images) {
      if (!img || !img.name) continue;
      const arrayBuffer = await img.arrayBuffer();
      const buffer = Buffer.from(arrayBuffer);
      const safeName = `${Date.now()}-${img.name.replace(/\s+/g, "_")}`;
      const imgPath = path.join(uploadDir, safeName);
      fs.writeFileSync(imgPath, buffer);
      imagePaths.push(`/uploads/${safeName}`);
    }

    const products = readProducts();
    const newProduct = {
      id: Date.now(),
      name,
      price,
      description,
      images: imagePaths,
    };

    products.push(newProduct);
    saveProducts(products);

    return NextResponse.json({ success: true, product: newProduct });
  } catch (err) {
    console.error("‚ùå L·ªói POST:", err);
    return NextResponse.json(
      { success: false, error: "L·ªói th√™m s·∫£n ph·∫©m" },
      { status: 500 }
    );
  }
}

// ==============================
// üîπ PUT ‚Äî C·∫≠p nh·∫≠t s·∫£n ph·∫©m
// ==============================
export async function PUT(req: Request) {
  try {
    const contentType = req.headers.get("content-type") || "";
    let updatedData: any = {};

    // üß© N·∫øu client g·ª≠i JSON
    if (contentType.includes("application/json")) {
      updatedData = await req.json();
    }
    // üñº N·∫øu client g·ª≠i formData
    else if (contentType.includes("multipart/form-data")) {
      const formData = await req.formData();
      updatedData.id = Number(formData.get("id"));
      updatedData.name = formData.get("name");
      updatedData.price = formData.get("price");
      updatedData.description = formData.get("description");

      const images = formData.getAll("images") as File[];
      if (images.length) {
        if (!fs.existsSync(uploadDir)) fs.mkdirSync(uploadDir, { recursive: true });
        updatedData.images = [];

        for (const img of images) {
          if (!img || !img.name) continue;
          const arrayBuffer = await img.arrayBuffer();
          const buffer = Buffer.from(arrayBuffer);
          const safeName = `${Date.now()}-${img.name.replace(/\s+/g, "_")}`;
          const imgPath = path.join(uploadDir, safeName);
          fs.writeFileSync(imgPath, buffer);
          updatedData.images.push(`/uploads/${safeName}`);
        }
      }
    }

    if (!updatedData.id)
      return NextResponse.json(
        { success: false, message: "Thi·∫øu ID s·∫£n ph·∫©m" },
        { status: 400 }
      );

    const products = readProducts();
    const index = products.findIndex((p: any) => p.id === updatedData.id);
    if (index === -1)
      return NextResponse.json(
        { success: false, message: "Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m" },
        { status: 404 }
      );

    // üß† Gi·ªØ nguy√™n h√¨nh ·∫£nh c≈© n·∫øu kh√¥ng upload ·∫£nh m·ªõi
    products[index] = {
      ...products[index],
      ...updatedData,
      images: updatedData.images || products[index].images,
    };

    saveProducts(products);
    return NextResponse.json({ success: true, product: products[index] });
  } catch (err) {
    console.error("‚ùå L·ªói PUT:", err);
    return NextResponse.json(
      { success: false, error: "L·ªói c·∫≠p nh·∫≠t s·∫£n ph·∫©m" },
      { status: 500 }
    );
  }
}

// ==============================
// üîπ DELETE ‚Äî X√≥a s·∫£n ph·∫©m
// ==============================
export async function DELETE(req: Request) {
  try {
    const { searchParams } = new URL(req.url);
    const id = Number(searchParams.get("id"));
    if (!id)
      return NextResponse.json(
        { success: false, message: "Thi·∫øu ID s·∫£n ph·∫©m" },
        { status: 400 }
      );

    const products = readProducts();
    const newProducts = products.filter((p: any) => p.id !== id);
    saveProducts(newProducts);

    return NextResponse.json({ success: true });
  } catch (err) {
    console.error("‚ùå L·ªói DELETE:", err);
    return NextResponse.json(
      { success: false, error: "Kh√¥ng th·ªÉ x√≥a s·∫£n ph·∫©m" },
      { status: 500 }
    );
  }
}
